#### 练习 1：理解内核启动中的程序入口操作 

**阅读`kern/init/entry.S`内容代码，结合操作系统内核启动流程，说明指令 `la sp, bootstacktop` 完成了什么操作， 目的是什么？`tail kern_init` 完成了什么操作，目的是什么？**

对于指令 `la sp, bootstacktop`，`la` 指令是伪指令，它用于加载一个地址（而不是实际的数据）到目标寄存器中。在这里，目标寄存器是栈指针寄存器 `sp`。这个指令通过加载 bootstacktop 的地址到栈指针寄存器 sp，这个指令初始化了栈指针，将其指向了启动堆栈的顶部。换句话说，它设置了操作系统启动时的初始堆栈位置。这个指令的主要目的是确保在操作系统启动时有一个合适的堆栈供程序使用。堆栈在计算机系统中用于存储函数调用的上下文信息、临时数据以及其他重要信息。通过初始化堆栈指针，操作系统可以确保在初始化过程中的函数调用和数据存储都会使用到正确的堆栈空间。

对于 `tail kern_init`，`tail kern_init` 是一个函数调用指令，它将程序的控制流转移到 `kern_init` 函数的代码开始处。这意味着在执行这条指令之后，操作系统会开始执行` kern_init` 函数中的指令。目的是进行操作系统的初始化工作。在操作系统启动过程中，有许多初始化任务需要完成，例如设置全局数据结构、初始化硬件设备、建立中断处理程序等等。这些初始化任务非常重要，因为它们确保了操作系统在正常运行之前具备了必要的基础设置和功能。

 

#### 练习 2：完善中断处理（需要编程）

**请编程完善 trap.c 中的中断处理函数 trap，在对时钟中断进行处理的部分填写 kern/trap/trap.c 函数中处理时钟中断的部分，使操作系统每遇到 100 次时钟中断后，调用 print_ticks 子程序，向屏幕上打印一行文字”100 ticks”，在打印完 10 行后调用 sbi.h 中的 shut_down() 函数关机。** 

**要求完成问题 1 提出的相关函数实现，提交改进后的源代码包（可以编译执行），并在实验报告中简要说明实现过程和定时器中断中断处理的流程。实现要求的部分代码后，运行整个系统，大约每 1 秒会输出一次”100 ticks”，输出 10 行。** 

在注释后添加的代码为：
```

      clock_set_next_event();

​      ticks++;

​      if (ticks == 100) {

​        print_ticks();

​        num++;

​        ticks = 0;

​      }

​      if (num == 10) {

​        sbi_shutdown();

​      }
```
 

 

#### 扩展练习 Challenge1：描述与理解中断流程

**回答：描述 ucore 中处理中断异常的流程（从异常的产生开始），其中 `mov a0，sp` 的目的是什么？SAVE_ALL中寄存器保存在栈中的位置是什么确定的？对于任何中断，`__alltraps` 中都需要保存所有寄存器吗？请说明理由。** 

ucore 中处理中断异常的流程：

1. 异常的产生：异常可以是来自硬件的中断（例如，时钟中断、键盘中断）或者来自软件的异常（例如，除以零、非法指令）。当异常发生时，CPU 将会执行特定的处理程序，这个程序被称为异常处理程序或中断处理程序。
2. 保存上下文：在处理异常之前，CPU 需要保存当前的执行上下文，以便在异常处理程序执行完毕后能够继续执行被中断的代码。通常，CPU 会将一些寄存器的值保存到内存中，以便以后恢复。这些寄存器包括通用寄存器、程序计数器（PC）等。
3. 跳转到异常处理程序：CPU 会根据异常类型和异常向量表找到相应的异常处理程序的地址，并跳转到该地址。异常处理程序是操作系统内核中的一部分，负责处理特定类型的异常或中断。
4. 处理异常：异常处理程序会根据异常的类型执行相应的操作，例如，如果是时钟中断，可能会更新系统时间；如果是非法指令，可能会终止进程等。
5. 恢复上下文：在异常处理程序执行完毕后，需要恢复之前保存的上下文，以便继续执行被中断的代码。之前保存的寄存器值会被重新加载，程序计数器会设置为中断发生时的下一条指令。

 

对于`mov a0，sp`，在RISC-V架构中，`a0` 寄存器通常用于保存函数的第一个参数。`sp` 寄存器是栈指针，指向当前栈帧的顶部。`mov a0, sp `的目的是将栈指针保存到 `a0` 寄存器，以便在异常处理程序中可以访问当前栈帧的信息。这种操作有助于异常处理程序分析栈上的数据或执行与栈有关的操作。

 

`SAVE_ALL`是一个汇编宏，用来保存所有寄存器到栈顶（实际上把一个 trapFrame 结构体放到了栈顶）。其中寄存器保存在栈中的位置可能由以下原因确定：

1.栈指针 (`SP`) 的位置：通常，保存到栈中的寄存器值的位置是由栈指针 (`SP`) 决定的。`SP `指向栈顶，寄存器值从栈顶依次往下保存。在某些架构中，`SP `指向的是栈的底部，然后寄存器值从栈底往上保存。

2.栈帧：寄存器值通常保存在当前函数的栈帧中。栈帧是一块用于存储局部变量和保存寄存器的内存区域。栈帧的布局通常是由编译器或汇编宏来定义的，遵循特定的调用约定。

3.调用约定：不同的编程语言和操作系统可能有不同的调用约定，这些约定规定了函数如何保存和恢复寄存器的值。例如，在x86架构上，C语言的调用约定要求在栈上保存一些寄存器，而在RISC-V架构上，调用约定可能不同。

4.异常处理程序的需求：异常处理程序可能需要保存一些特定的寄存器，具体要求取决于异常的类型和处理程序的功能。保存的寄存器通常包括通用寄存器、程序计数器（PC）等。

 

对于任何中断，`__alltraps `中并不是都需要保存所有寄存器，可能的原因有：

1. 性能考虑：保存和恢复所有寄存器需要大量的指令和内存操作，这会引入不必要的性能开销。在异常处理过程中，通常只有一部分寄存器需要保存和恢复，例如，通用寄存器、程序计数器等。
2. 上下文切换：异常处理通常是在进程之间或者在用户态和内核态之间进行上下文切换的时候触发的。为了减小上下文切换的开销，只有必要的寄存器需要保存和恢复。
3. 异常处理程序的需求：不同的异常处理程序可能需要不同的寄存器。例如，时钟中断处理程序可能只需要保存和恢复通用寄存器，而页错误处理程序可能需要额外保存一些特殊寄存器或状态寄存器。
4. 栈的使用：通常，保存和恢复寄存器的操作会使用栈来存储寄存器值。如果保存所有寄存器，栈的空间需求会非常大，可能导致栈溢出或浪费大量内存。

 

#### 扩增练习 Challenge2：理解上下文切换机制

**回答：在 `trapentry.S` 中汇编代码 `csrw sscratch, sp；csrrw s0, sscratch, x0` 实现了什么操作，目的是什么？save all里面保存了 `stval scause` 这些`csr`，而在 `restore all` 里面却不还原它们？那这样 `store` 的意义何在呢？** 

 

对于`csrw sscratch, sp`，这行指令是一个 CSR 写操作，用于将栈指针（`sp` 寄存器）的值写入 sscratch 寄存器。

sscratch 寄存器是 RISC-V 架构中的一个特殊寄存器，通常用于保存临时状态。在中断或异常处理期间，保存` sp `寄存器的值到 sscratch 的目的是为了在处理中断或异常期间，能够在需要时恢复原始的栈指针值，以确保中断或异常处理的正确性。

对于`csrrw s0, sscratch, x0`，这行指令是一个 CSR 读写操作，它从 sscratch 寄存器中读取值，并将这个值写入 `s0 `寄存器，同时将 x0 的值写回 sscratch 寄存器。目的是将 sscratch 寄存器的值保存到 s0 寄存器中，同时清零 sscratch 寄存器的内容。这通常用于备份 sscratch 寄存器的值，因为在中断或异常处理期间，sscratch 寄存器可能会被用于其他目的，所以需要保存其原始值，以便在恢复时使用。

这两行指令的目的是在中断或异常处理期间，保存和恢复 sscratch 寄存器的值，以确保正确地处理中断或异常，并保持程序的正确性。

未还原的csr寄存器为sbadaddr和scause，它们分别是用于记录最后一次访问失败的地址和用于存储发生异常或中断时的异常原因代码的寄存器，因此在异常处理完之后这些寄存器中的数据已经没有作用了，因此不用还原。

 

 

#### 扩展练习 Challenge3：完善异常中断

**编程完善在触发一条非法指令异常 mret 和，在` kern/trap/trap.c` 的异常处理函数中捕获，并对其进行处理，简单输出异常类型和异常指令触发地址，即“`Illegal instruction caught at 0x`(地址)”，“`ebreak caught at 0x`（地址）”与“`Exception type:Illegal instruction`”，“`Exception type: breakpoint`”。**

 

在注释后添加的两段代码为

```
cprintf("Exception type:Illegal instruction\n");
cprintf("Illegal instruction caught at %lx\n", tf->epc);
tf->epc += 4;
```
 
```
cprintf("Exception type: breakpoint\n");
cprintf("ebreak caught at %lx\n", tf->epc);
tf->epc += 4;
```





 

 

 

 

 
